<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>golang 统计代码行数</title>
    <url>/2022/08/31/2022-08-31-golang-%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/</url>
    <content><![CDATA[<h1 id="golang-统计代码行数"><a href="#golang-统计代码行数" class="headerlink" title="golang 统计代码行数"></a>golang 统计代码行数</h1><h2 id="使用gocloc工具进行统计"><a href="#使用gocloc工具进行统计" class="headerlink" title="使用gocloc工具进行统计"></a>使用gocloc工具进行统计</h2><p>获取gocloc工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/hhatto/gocloc/cmd/gocloc</span><br></pre></td></tr></table></figure>
<p>使用gocloc命令 gocloc[目录路径或文件路径] 进行统计</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gocloc .</span><br></pre></td></tr></table></figure>

<p><code>gocloc</code>会按类别统计路径下有多少文件，文件中的空行数，注释行数以及实际代码行数。如果目录下某类文件不需要统计，可以使用参数<code>--exclue-ext=[文件后缀]</code></p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gocloc --exclue-ext=txt .</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 备份(mongodump)与恢复(mongorestore)</title>
    <url>/2022/02/16/MongoDB%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="MongoDB-备份-mongodump-与恢复-mongorestore"><a href="#MongoDB-备份-mongodump-与恢复-mongorestore" class="headerlink" title="MongoDB 备份(mongodump)与恢复(mongorestore)"></a>MongoDB 备份(mongodump)与恢复(mongorestore)</h1><hr>
<h2 id="MongoDB数据备份"><a href="#MongoDB数据备份" class="headerlink" title="MongoDB数据备份"></a>MongoDB数据备份</h2><p>在Mongodb中我们使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。</p>
<p>mongodump命令可以通过参数指定导出的数据量级转存的服务器。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>mongodump命令脚本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>mongodump <span class="operator">-</span>h dbhost <span class="operator">-</span>d dbname <span class="operator">-</span>o dbdirectory</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-h：</p>
<p>MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p>
</li>
<li><p>-d：</p>
<p>需要备份的数据库实例，例如：test</p>
</li>
<li><p>-o：</p>
<p>备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</p>
</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在本地使用 27017 启动你的mongod服务。打开命令提示符窗口，进入MongoDB安装目录的bin目录输入命令mongodump:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;mongodump</span><br></pre></td></tr></table></figure>

<p>执行以上命令后，客户端会连接到ip为 127.0.0.1 端口号为 27017 的MongoDB服务上，并备份所有数据到 bin&#x2F;dump&#x2F; 目录中。命令输出结果如下：</p>
<p>mongodump 命令可选参数列表如下所示：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>mongodump –host HOST_NAME –port PORT_NUMBER</td>
<td>该命令将备份所有MongoDB数据</td>
<td>mongodump –host runoob.com –port 27017</td>
</tr>
<tr>
<td>mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY</td>
<td></td>
<td>mongodump –dbpath &#x2F;data&#x2F;db&#x2F; –out &#x2F;data&#x2F;backup&#x2F;</td>
</tr>
<tr>
<td>mongodump –collection COLLECTION –db DB_NAME</td>
<td>该命令将备份指定数据库的集合。</td>
<td>mongodump –collection mycol –db test</td>
</tr>
</tbody></table>
<hr>
<h2 id="MongoDB数据恢复"><a href="#MongoDB数据恢复" class="headerlink" title="MongoDB数据恢复"></a>MongoDB数据恢复</h2><p>mongodb使用 mongorestore 命令来恢复备份的数据</p>
<h3 id="mongorestore命令脚本语法如下"><a href="#mongorestore命令脚本语法如下" class="headerlink" title="mongorestore命令脚本语法如下"></a>mongorestore命令脚本语法如下</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>–host &lt;:port&gt;, -h &lt;:port&gt;：</p>
<p>MongoDB所在服务器地址，默认为： localhost:27017</p>
</li>
<li><p>–db , -d ：</p>
<p>需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2</p>
</li>
<li><p>–drop：</p>
<p>恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！</p>
</li>
<li><p><code>&lt;path&gt;</code>：</p>
<p>mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。</p>
<p>你不能同时指定 <code>&lt;path&gt;</code> 和 –dir 选项，–dir也可以设置备份目录。</p>
</li>
<li><p>–dir：</p>
<p>指定备份的目录</p>
<p>你不能同时指定 <code>&lt;path&gt;</code> 和 –dir 选项。</p>
</li>
</ul>
<p>接下来我们执行以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;mongorestore</span><br></pre></td></tr></table></figure>

<p>执行以上命令输出结果如下：</p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>备份</tag>
        <tag>恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>GPG入门教程</title>
    <url>/2022/03/01/GPG%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>原文链接：<a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html">http://www.ruanyifeng.com/blog/2013/07/gpg.html</a></p>
]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>gpg</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse安装使用笔记</title>
    <url>/2022/12/14/clickhouse%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="clickhouse"><a href="#clickhouse" class="headerlink" title="clickhouse"></a>clickhouse</h1><h2 id="clickhouse入门"><a href="#clickhouse入门" class="headerlink" title="clickhouse入门"></a>clickhouse入门</h2><p>clickhouse 的特点：</p>
<ul>
<li><p>列式存储</p>
</li>
<li><p>DBMS的功能</p>
</li>
<li><p>多样化引擎 （merge_tree)</p>
</li>
<li><p>高吞吐写入能力</p>
</li>
<li><p>数据分区与线程级并行</p>
</li>
<li><p>性能-不适合用join查询</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>ClickHouse安装准备</strong></p>
<ul>
<li><p>确定防火墙关闭</p>
</li>
<li><p>Centos取消打开文件限制-&gt;用户可用文件数、用户可用最大进程数</p>
</li>
<li><p>安装依赖</p>
</li>
<li><p>CentOS取消SELINUX</p>
</li>
<li><p>查看selinux状态</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getenforce</span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;selinux&#x2F;config中的SELINUX&#x3D;disabled</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>重启生效</p>
<p>如果不想关闭机器，临时生效，如果是关闭状态必须重启机器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>

<p> 执行同步操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /home/user/bin/xsync/etc/selinux/config</span><br></pre></td></tr></table></figure>

<p><strong>下载安装包</strong></p>
<ul>
<li>client  </li>
<li>common-static </li>
<li>common-static-dbg</li>
<li>server</li>
</ul>
<p><strong>版本差异</strong></p>
<ul>
<li>20.5 支持多线程</li>
<li>20.6.3+ explain(执行计划)</li>
<li>20.8 -&gt; 实时同步mysql新引擎</li>
</ul>
<p><strong>安装命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir clickhouse</span><br><span class="line">cd clickhouse</span><br><span class="line">sudo rpm -ivh *.rpm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入密码</span></span><br><span class="line">enter password for default user:******</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">确认安装状态</span></span><br><span class="line">rpm -qa|grep clickhouse</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示有四个安装包则成功</span></span><br><span class="line">clickhouse-server.noarch</span><br><span class="line">click-client.noarch</span><br><span class="line">click-common-static-dbg</span><br><span class="line">click-common-static</span><br></pre></td></tr></table></figure>
<h2 id="clickhouse操作"><a href="#clickhouse操作" class="headerlink" title="clickhouse操作"></a>clickhouse操作</h2><p>查看目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">bin目录</span></span><br><span class="line">cd /usr/bin/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">conf目录</span></span><br><span class="line">cd /etc/clickhouse-server/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">lib目录</span></span><br><span class="line">cd /var/lib/clickhouse</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">log</span>目录</span></span><br><span class="line">cd /var/log/clickhouse</span><br></pre></td></tr></table></figure>
<p>查看配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入clickhouse文件夹</span></span><br><span class="line">cd /etc/click-server/</span><br><span class="line">ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">config.xml 通用服务端配置，可以修改数据路径和日志路径</span></span><br><span class="line">config.d config.xml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">users.xml 用户一些参数配置</span></span><br><span class="line">users.d users.xml</span><br><span class="line"> </span><br><span class="line">vim config.xml </span><br><span class="line">查找listen,去掉注释，不对ip做限制</span><br><span class="line">&lt;lisetn_host&gt;::&lt;/listen_host&gt; </span><br></pre></td></tr></table></figure>
<p>clickhouse服务相关命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动server</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linux 查看状态</span></span><br><span class="line">sudo systemctl status clickhouse-server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">clickhouse 自带命令查看状态</span></span><br><span class="line">sudo clickhouse status</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">sudo clickhouse restart</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">clickhouse-client 命令</span></span><br><span class="line">clickhouse-client -help</span><br><span class="line">-m 分号换行</span><br><span class="line">-h 链接远程</span><br><span class="line">--query &quot;加上查询语句&quot; clickhouse-client --query &quot;show databases&quot;</span><br><span class="line">-p 端口</span><br></pre></td></tr></table></figure>
<p>clickhouse数据库操作命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">链接clickhouse</span></span><br><span class="line">clickhouse -m</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用库</span></span><br><span class="line">use system;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看表</span></span><br><span class="line">show tables;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询</span></span><br><span class="line">select * from users;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>channel的死锁和panic总结</title>
    <url>/2022/05/07/channel%E7%9A%84%E6%AD%BB%E9%94%81%E5%92%8Cpanic%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="channel的死锁和panic总结"><a href="#channel的死锁和panic总结" class="headerlink" title="channel的死锁和panic总结"></a>channel的死锁和panic总结</h1><h2 id="1-channel的容量为0时"><a href="#1-channel的容量为0时" class="headerlink" title="1.channel的容量为0时"></a>1.channel的容量为0时</h2><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">     <span class="comment">//一直接收不到消息发生阻塞，死锁</span></span><br><span class="line">	fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//发送消息的时候无人接收</span></span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">    <span class="comment">//接收消息 的时候无人发送 死锁</span></span><br><span class="line">	fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为channel size为0，之前把1传进c中，但是没有接收方，等到&lt;-c时，已经接收不到数据传入channel，所以死锁</p>
<h3 id="第三种情况"><a href="#第三种情况" class="headerlink" title="第三种情况"></a>第三种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//没有初始化</span></span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四种情况"><a href="#第四种情况" class="headerlink" title="第四种情况"></a>第四种情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//定义类型</span></span><br><span class="line">    c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">0</span>) <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            c &lt;- i <span class="comment">//传入channel数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span>  v := <span class="keyword">range</span> c&#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是死锁，应该将数据传进channel后，并没有关闭channel，for循环接收channel一直在监听，死锁</p>
<p>数据传进channel后，输入方主动关闭channel</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c) <span class="comment">//或者defer close(c)</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span>  v := <span class="keyword">range</span> c&#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="当channel-关闭且缓冲区为0时"><a href="#当channel-关闭且缓冲区为0时" class="headerlink" title="当channel 关闭且缓冲区为0时"></a>当channel 关闭且缓冲区为0时</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo6</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出为0</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭未初始化的channel，会panic"><a href="#关闭未初始化的channel，会panic" class="headerlink" title="关闭未初始化的channel，会panic"></a>关闭未初始化的channel，会panic</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo6</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    <span class="comment">//func1</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//func2</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;(ch)</span><br><span class="line">    c := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;#goroutines: %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一段时间后输出结果为#goroutines: 2</span></span><br></pre></td></tr></table></figure>
<p>结果中的goroutines分别为fun2 和 main函数，因为fun2没有初始化ch 所以会一直阻塞（func1中的初始化只在其所在的闭包函数中有效)</p>
<h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><ol>
<li>channel关闭后，再向channel中写入数据会panic</li>
<li>channel关闭后，再次关闭channel，会panic</li>
<li>关闭未初始化的channel，会panic</li>
<li>channel关闭后，可以继续从channel中接收数据</li>
<li>当channel 关闭且缓冲区为0时，继续从channel接收数据会接收到一个channel定义类型的零值</li>
<li>channel先进先出</li>
</ol>
<p>作者：coldwarm7<br>链接：<a href="https://www.jianshu.com/p/f25cdd72efce">https://www.jianshu.com/p/f25cdd72efce</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose 执行模板文件构建镜像</title>
    <url>/2022/02/15/docker-compose%E6%89%A7%E8%A1%8C%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><p>执行模板文件构建镜像</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose.build.yml build --no-cache</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 保存镜像到本地和加载镜像</title>
    <url>/2022/03/30/docker%E4%BF%9D%E5%AD%98%E9%95%9C%E5%83%8F%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%92%8C%E5%8A%A0%E8%BD%BD%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="docker-保存镜像到本地和加载镜像"><a href="#docker-保存镜像到本地和加载镜像" class="headerlink" title="docker 保存镜像到本地和加载镜像"></a>docker 保存镜像到本地和加载镜像</h1><h2 id="导出docker镜像，到linux本地"><a href="#导出docker镜像，到linux本地" class="headerlink" title="导出docker镜像，到linux本地"></a>导出docker镜像，到linux本地</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o   指定地址和文件名   镜像名 </span><br></pre></td></tr></table></figure>

<ul>
<li>例子：<br>把名字为test，版本为4.0的docker镜像，保存到&#x2F;data&#x2F;export目录下，保存名字和格式为test.tar<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o /data/export/test.tar <span class="built_in">test</span>:4.0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="加载镜像文件"><a href="#加载镜像文件" class="headerlink" title="加载镜像文件"></a>加载镜像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load &lt; 文件名</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git 标签</title>
    <url>/2022/02/16/git%20tag%20%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h1><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a v1.2.0 -m <span class="string">&quot;new version&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="显示标签以及备注"><a href="#显示标签以及备注" class="headerlink" title="显示标签以及备注"></a>显示标签以及备注</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -n</span><br></pre></td></tr></table></figure>

<h2 id="实现标签以及备注，按照打标签的时间排序"><a href="#实现标签以及备注，按照打标签的时间排序" class="headerlink" title="实现标签以及备注，按照打标签的时间排序"></a>实现标签以及备注，按照打标签的时间排序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -n --<span class="built_in">sort</span>=taggerdate</span><br></pre></td></tr></table></figure>

<p>–sort&#x3D;key</p>
<p>关于key的值可以参考 <a href="https://git-scm.com/docs/git-for-each-ref">https://git-scm.com/docs/git-for-each-ref</a></p>
<h2 id="同时有时间、tag、备注使用以下命令"><a href="#同时有时间、tag、备注使用以下命令" class="headerlink" title="同时有时间、tag、备注使用以下命令"></a>同时有时间、tag、备注使用以下命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git for-each-ref --<span class="built_in">sort</span>=taggerdate --format <span class="string">&#x27;%(refname:short) %(taggerdate:short) %(subject)&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="对某个版本进行补打标签，commitId-只要填入前7位即可"><a href="#对某个版本进行补打标签，commitId-只要填入前7位即可" class="headerlink" title="对某个版本进行补打标签，commitId 只要填入前7位即可"></a>对某个版本进行补打标签，commitId 只要填入前7位即可</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a v1.2 423445a</span><br></pre></td></tr></table></figure>

<h2 id="删除标签，并不会删除版本，只是删除标签"><a href="#删除标签，并不会删除版本，只是删除标签" class="headerlink" title="删除标签，并不会删除版本，只是删除标签"></a>删除标签，并不会删除版本，只是删除标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d v1.2</span><br></pre></td></tr></table></figure>

<h2 id="推送标签"><a href="#推送标签" class="headerlink" title="推送标签"></a>推送标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin master --tags</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>tag</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 拉取指定平台架构的镜像</title>
    <url>/2022/02/16/docker%E6%8B%89%E5%8F%96%E6%8C%87%E5%AE%9A%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="docker-拉取指定平台架构的镜像"><a href="#docker-拉取指定平台架构的镜像" class="headerlink" title="docker 拉取指定平台架构的镜像"></a>docker 拉取指定平台架构的镜像</h1><p>有时候我们需要拉取指定平台架构的镜像但是我们又没有对应架构的服务器和硬件的时候：<br>比如我们需要拉取一个arm64的node镜像，首先进入docker hub 搜索node镜像<br><img src="/upload/2022/03/image-f8364fe234a64afe9a6c1d20ee65a75e.png" alt="image.png"><br>复制digest<br><img src="/upload/2022/03/image-38e509972a8f4187982b3a5922ff0072.png" alt="image.png"><br>拉取对应版本和对应架构的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull nginx:latest@sha256:3df2ee4220cd7ce126d98cad124c93ed81ea58ee050400ec3c3bca3b553d5448</span><br></pre></td></tr></table></figure>
<p>在DOCKERFILE文件里面</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:latest@sha256:<span class="number">3</span>df2ee4220cd7ce126d98cad124c93ed81ea58ee050400ec3c3bca3b553d5448</span><br></pre></td></tr></table></figure>
<p>成功拉取</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git add 暂存</title>
    <url>/2022/02/16/git%20add%20%E6%9A%82%E5%AD%98/</url>
    <content><![CDATA[<h1 id="add命令"><a href="#add命令" class="headerlink" title="add命令"></a>add命令</h1><h2 id="git-add-命令可将该文件添加到暂存区。"><a href="#git-add-命令可将该文件添加到暂存区。" class="headerlink" title="git add 命令可将该文件添加到暂存区。"></a>git add 命令可将该文件添加到暂存区。</h2><p>添加一个或多个文件到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [fle1] [file2] ...</span><br></pre></td></tr></table></figure>

<p>添加指定目录到暂存区，包括子目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [<span class="built_in">dir</span>]</span><br></pre></td></tr></table></figure>

<p>添加当前目录下的所有文件到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>add</tag>
      </tags>
  </entry>
  <entry>
    <title>git 报错refusing to merge unrelated histories，强制提交</title>
    <url>/2022/02/16/git%20%E6%8A%A5%E9%94%99refusing%20to%20merge%20unrelated%20histories%EF%BC%8C%E5%BC%BA%E5%88%B6%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<p>拉取代码或者推送代码报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">refusing to merge unrelated histories</span><br></pre></td></tr></table></figure>

<p>解决：<br>方法一: 允许不相关历史提交，并强制合并</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<p>方法二： 强制提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git 文件状态 、status</title>
    <url>/2022/02/16/git%20%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%20%E3%80%81status/</url>
    <content><![CDATA[<h1 id="git-status命令"><a href="#git-status命令" class="headerlink" title="git status命令"></a>git status命令</h1><p>查看文件更改状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>带文件状态码查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>A</strong>: 你本地新增的文件（服务器上没有）.</p>
</li>
<li><p><strong>C</strong>: 文件的一个新拷贝.</p>
</li>
<li><p><strong>D</strong>: 你本地删除的文件（服务器上还在）.</p>
</li>
<li><p><strong>M</strong>: 文件的内容或者mode被修改了.</p>
</li>
<li><p><strong>R</strong>: 文件名被修改了。</p>
</li>
<li><p><strong>T</strong>: 文件的类型被修改了。</p>
</li>
<li><p><strong>U</strong>: 文件没有被合并(你需要完成合并才能进行提交)。</p>
</li>
<li><p><strong>X</strong>: 未知状态(很可能是遇到git的bug了，你可以向git提交bug report)</p>
</li>
<li><p>**?**：未被git进行管理，可以使用git add file1把file1添加进git能被git所进行管理</p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>文件</tag>
        <tag>status</tag>
      </tags>
  </entry>
  <entry>
    <title>git 查看提交历史记录</title>
    <url>/2022/02/16/git%20%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="查看历史"><a href="#查看历史" class="headerlink" title="查看历史"></a>查看历史</h1><h2 id="查看所有提交历史记录"><a href="#查看所有提交历史记录" class="headerlink" title="查看所有提交历史记录"></a>查看所有提交历史记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>–oneline 查看历史记录简洁版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>

<h2 id="查看指定文件的修改记录"><a href="#查看指定文件的修改记录" class="headerlink" title="查看指定文件的修改记录"></a>查看指定文件的修改记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>history</tag>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>git 设置ssh 代理</title>
    <url>/2022/02/16/git%20%E8%AE%BE%E7%BD%AEssh%20%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>配置文件，如果不存在则自行创建一个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~\.ssh\config</span><br></pre></td></tr></table></figure>

<p>增加内容,端口号设置socks端口号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ProxyCommand connect -S 127.0.0.1:10808 -a none %h %p</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname github.com</span><br><span class="line">  <span class="comment"># 注意修改路径为你的路径</span></span><br><span class="line">  IdentityFile <span class="string">&quot;~\.ssh\id_rsa&quot;</span></span><br><span class="line">  TCPKeepAlive <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">Host ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  <span class="comment"># 注意修改路径为你的路径</span></span><br><span class="line">  IdentityFile <span class="string">&quot;~\.ssh\id_rsa&quot;</span></span><br><span class="line">  TCPKeepAlive <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>git 配置http代理</title>
    <url>/2022/02/16/git%20%E9%85%8D%E7%BD%AEhttp%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>设置代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080  </span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>取消代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>git 配置用户名邮箱</title>
    <url>/2022/02/16/git%20%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E5%90%8D%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="git全局用户名邮箱配置"><a href="#git全局用户名邮箱配置" class="headerlink" title="git全局用户名邮箱配置"></a>git全局用户名邮箱配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name  <span class="string">&quot;username&quot;</span>  </span><br><span class="line">git config --global user.email  <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="git局部用户名邮箱配置"><a href="#git局部用户名邮箱配置" class="headerlink" title="git局部用户名邮箱配置"></a>git局部用户名邮箱配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config  user.name  <span class="string">&quot;username&quot;</span>  </span><br><span class="line">git config  user.email  <span class="string">&quot;email&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改已有配置信息"><a href="#修改已有配置信息" class="headerlink" title="修改已有配置信息"></a>修改已有配置信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --replace-all user.name <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line">git config --replace-all user.email <span class="string">&quot;123@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意：局部变量覆盖全局变量！！！"><a href="#注意：局部变量覆盖全局变量！！！" class="headerlink" title="注意：局部变量覆盖全局变量！！！"></a>注意：局部变量覆盖全局变量！！！</h3>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>golang AES算法 CBC加密</title>
    <url>/2022/04/18/golang%20AES%E7%AE%97%E6%B3%95%20CBC%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> aes</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/cipher&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//pkcs7Padding 填充</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pkcs7Padding</span><span class="params">(data []<span class="type">byte</span>, blockSize <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">//判断缺少几位长度。最少1，最多 blockSize</span></span><br><span class="line">	padding := blockSize - <span class="built_in">len</span>(data)%blockSize</span><br><span class="line">	<span class="comment">//补足位数。把切片[]byte&#123;byte(padding)&#125;复制padding个</span></span><br><span class="line">	padText := bytes.Repeat([]<span class="type">byte</span>&#123;<span class="type">byte</span>(padding)&#125;, padding)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(data, padText...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pkcs7UnPadding 填充的反向操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pkcs7UnPadding</span><span class="params">(data []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(data)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;加密字符串错误！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取填充的个数</span></span><br><span class="line">	unPadding := <span class="type">int</span>(data[length<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">return</span> data[:(length - unPadding)], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AesEncrypt 加密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesEncrypt</span><span class="params">(data []<span class="type">byte</span>, key []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//创建加密实例</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断加密快的大小</span></span><br><span class="line">	blockSize := block.BlockSize()</span><br><span class="line">	<span class="comment">//填充</span></span><br><span class="line">	encryptBytes := pkcs7Padding(data, blockSize)</span><br><span class="line">	<span class="comment">//初始化加密数据接收切片</span></span><br><span class="line">	crypted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(encryptBytes))</span><br><span class="line">	<span class="comment">//使用cbc加密模式</span></span><br><span class="line">	blockMode := cipher.NewCBCEncrypter(block, key[:blockSize])</span><br><span class="line">	<span class="comment">//执行加密</span></span><br><span class="line">	blockMode.CryptBlocks(crypted, encryptBytes)</span><br><span class="line">	<span class="keyword">return</span> crypted, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AesDecrypt 解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesDecrypt</span><span class="params">(data []<span class="type">byte</span>, key []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">//创建实例</span></span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取块的大小</span></span><br><span class="line">	blockSize := block.BlockSize()</span><br><span class="line">	<span class="comment">//使用cbc</span></span><br><span class="line">	blockMode := cipher.NewCBCDecrypter(block, key[:blockSize])</span><br><span class="line">	<span class="comment">//初始化解密数据接收切片</span></span><br><span class="line">	crypted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line">	<span class="comment">//执行解密</span></span><br><span class="line">	blockMode.CryptBlocks(crypted, data)</span><br><span class="line">	<span class="comment">//去除填充</span></span><br><span class="line">	crypted, err = pkcs7UnPadding(crypted)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> crypted, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//EncryptByAes Aes加密 后 base64 再加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptByAes</span><span class="params">(data, key []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	res, err := AesEncrypt(data, key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> base64.StdEncoding.EncodeToString(res), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DecryptByAes Aes 解密</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecryptByAes</span><span class="params">(data, key <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	dataByte, err := base64.StdEncoding.DecodeString(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> AesDecrypt(dataByte, []<span class="type">byte</span>(key))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>aes</tag>
        <tag>cbc</tag>
      </tags>
  </entry>
  <entry>
    <title>golang AES算法 ECB模式加密</title>
    <url>/2022/04/18/golang%20AES%E7%AE%97%E6%B3%95%20ECB%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> aes</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/aes&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EcbDecrypt</span><span class="params">(data, key []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	decrypted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line">	size := block.BlockSize()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> bs, be := <span class="number">0</span>, size; bs &lt; <span class="built_in">len</span>(data); bs, be = bs+size, be+size &#123;</span><br><span class="line">		block.Decrypt(decrypted[bs:be], data[bs:be])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PKCS5UnPadding(decrypted), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EcbEncrypt</span><span class="params">(data, key []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	block, err := aes.NewCipher(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	data = PKCS5Padding(data, block.BlockSize())</span><br><span class="line">	decrypted := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line">	size := block.BlockSize()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> bs, be := <span class="number">0</span>, size; bs &lt; <span class="built_in">len</span>(data); bs, be = bs+size, be+size &#123;</span><br><span class="line">		block.Encrypt(decrypted[bs:be], data[bs:be])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> decrypted, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5Padding</span><span class="params">(ciphertext []<span class="type">byte</span>, blockSize <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	padding := blockSize - <span class="built_in">len</span>(ciphertext)%blockSize</span><br><span class="line">	padtext := bytes.Repeat([]<span class="type">byte</span>&#123;<span class="type">byte</span>(padding)&#125;, padding)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(ciphertext, padtext...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PKCS5UnPadding</span><span class="params">(origData []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(origData)</span><br><span class="line">	<span class="comment">// 去掉最后一个字节 unpadding 次</span></span><br><span class="line">	unpadding := <span class="type">int</span>(origData[length<span class="number">-1</span>])</span><br><span class="line">	<span class="keyword">return</span> origData[:(length - unpadding)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>aes</tag>
        <tag>ecb</tag>
      </tags>
  </entry>
  <entry>
    <title>go mod tidy 报错timeout</title>
    <url>/2022/05/05/go%20mod%20tidy%20%E6%8A%A5%E9%94%99timeout/</url>
    <content><![CDATA[<h1 id="go-mod-tidy-报错timeout"><a href="#go-mod-tidy-报错timeout" class="headerlink" title="go mod tidy 报错timeout"></a>go mod tidy 报错timeout</h1><p>当我们设置了GOPROXY代理之后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.io,direct</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<p>执行 go mod tidy 命令报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br><span class="line">github.com/spf13/viper: github.com/spf13/viper@v1.11.0: verifying module: github.com/spf13/viper@v1.11.0: Get <span class="string">&quot;https://sum.golang.org/lookup/github.com/spf13/viper@v1.11.0&quot;</span>: dial tcp 142.251.42.241:443: i/o <span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>
<p>报错是因为更改了GOPROXY 导致校验不通过<br>解决办法<br>1.关闭GOSUMDB 校验</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOSUMDB=off</span><br></pre></td></tr></table></figure>
<p>2.设置另一个国内可用的sum验证服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GOSUMDB=<span class="string">&quot;sum.golang.google.cn&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 获取系统相关信息</title>
    <url>/2022/03/01/golang%20%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">`系统类型：`</span>, runtime.GOOS)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">`系统架构：`</span>, runtime.GOARCH)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">`CPU 核数：`</span>, runtime.GOMAXPROCS(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    name, err := os.Hostname()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">`电脑名称：`</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 使用pprof 进行性能分析</title>
    <url>/2022/02/16/golang%E4%BD%BF%E7%94%A8pprof%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="golang-性能分析"><a href="#golang-性能分析" class="headerlink" title="golang 性能分析"></a>golang 性能分析</h1><h2 id="性能分析web地址"><a href="#性能分析web地址" class="headerlink" title="性能分析web地址"></a>性能分析web地址</h2><p><a href="http://ip:port/debug/pprof/">http://ip:port/debug/pprof/</a></p>
<span id="more"></span>
<h2 id="go-tool-命令"><a href="#go-tool-命令" class="headerlink" title="go tool 命令"></a>go tool 命令</h2><p>top 排序</p>
<p>list 列出调用栈</p>
<h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><ul>
<li>-insue_space 生成当前程序内存占用图</li>
<li>–alloc_space 生成历史内存占用图</li>
</ul>
<h3 id="命令行生成svg图片分析"><a href="#命令行生成svg图片分析" class="headerlink" title="命令行生成svg图片分析"></a>命令行生成svg图片分析</h3><ul>
<li>go tool pprof -inuse_space -cum -svg <a href="http://ip:port/debug/pprof/heap">http://ip:port/debug/pprof/heap</a> &gt; heap_inuse1.svg</li>
</ul>
<h2 id="cpu占用分析"><a href="#cpu占用分析" class="headerlink" title="cpu占用分析"></a>cpu占用分析</h2><h3 id="命令行分析"><a href="#命令行分析" class="headerlink" title="命令行分析"></a>命令行分析</h3><ul>
<li>go tool pprof im_gate cpu.prof # im_gate 是程序名字</li>
</ul>
<h3 id="生成图片分析"><a href="#生成图片分析" class="headerlink" title="生成图片分析"></a>生成图片分析</h3><ul>
<li>go tool pprof -png <a href="http://127.0.0.1:8888/debug/pprof/profile">http://127.0.0.1:8888/debug/pprof/profile</a> &gt; cpu.png</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>pprof</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 字符串、json、map之间转换</title>
    <url>/2022/02/16/golang%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81json%E3%80%81map%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="golang-字符串、json、map之间的转换"><a href="#golang-字符串、json、map之间的转换" class="headerlink" title="golang 字符串、json、map之间的转换"></a>golang 字符串、json、map之间的转换</h1><span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfigStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">   Host              <span class="type">string</span>   <span class="string">`json:&quot;host&quot;`</span></span><br><span class="line">   Port              <span class="type">int</span>      <span class="string">`json:&quot;port&quot;`</span></span><br><span class="line">   AnalyticsFile     <span class="type">string</span>   <span class="string">`json:&quot;analytics_file&quot;`</span></span><br><span class="line">   StaticFileVersion <span class="type">int</span>      <span class="string">`json:&quot;static_file_version&quot;`</span></span><br><span class="line">   StaticDir         <span class="type">string</span>   <span class="string">`json:&quot;static_dir&quot;`</span></span><br><span class="line">   TemplatesDir      <span class="type">string</span>   <span class="string">`json:&quot;templates_dir&quot;`</span></span><br><span class="line">   SerTcpSocketHost  <span class="type">string</span>   <span class="string">`json:&quot;serTcpSocketHost&quot;`</span></span><br><span class="line">   SerTcpSocketPort  <span class="type">int</span>      <span class="string">`json:&quot;serTcpSocketPort&quot;`</span></span><br><span class="line">   Fruits            []<span class="type">string</span> <span class="string">`json:&quot;fruits&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Other <span class="keyword">struct</span> &#123;</span><br><span class="line">   SerTcpSocketHost <span class="type">string</span>   <span class="string">`json:&quot;serTcpSocketHost&quot;`</span></span><br><span class="line">   SerTcpSocketPort <span class="type">int</span>      <span class="string">`json:&quot;serTcpSocketPort&quot;`</span></span><br><span class="line">   Fruits           []<span class="type">string</span> <span class="string">`json:&quot;fruits&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   jsonStr := <span class="string">`&#123;&quot;host&quot;: &quot;http://localhost:9090&quot;,&quot;port&quot;: 9090,&quot;analytics_file&quot;: &quot;&quot;,&quot;static_file_version&quot;: 1,&quot;static_dir&quot;: &quot;E:/Project/goTest/src/&quot;,&quot;templates_dir&quot;: &quot;E:/Project/goTest/src/templates/&quot;,&quot;serTcpSocketHost&quot;: &quot;:12340&quot;,&quot;serTcpSocketPort&quot;: 12340,&quot;fruits&quot;: [&quot;apple&quot;, &quot;peach&quot;]&#125;`</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//json str 转map</span></span><br><span class="line">   <span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;dat); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;==============json str 转map=======================&quot;</span>)</span><br><span class="line">      fmt.Println(dat)</span><br><span class="line">      fmt.Println(dat[<span class="string">&quot;host&quot;</span>])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//json str 转struct</span></span><br><span class="line">   <span class="keyword">var</span> config ConfigStruct</span><br><span class="line">   <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;config); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;================json str 转struct==&quot;</span>)</span><br><span class="line">      fmt.Println(config)</span><br><span class="line">      fmt.Println(config.Host)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//json str 转struct(部份字段)</span></span><br><span class="line">   <span class="keyword">var</span> part Other</span><br><span class="line">   <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;part); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;================json str 转struct==&quot;</span>)</span><br><span class="line">      fmt.Println(part)</span><br><span class="line">      fmt.Println(part.SerTcpSocketPort)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//struct 到json str</span></span><br><span class="line">   <span class="keyword">if</span> b, err := json.Marshal(config); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;================struct 到json str==&quot;</span>)</span><br><span class="line">      fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//map 到json str</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;================map 到json str=====================&quot;</span>)</span><br><span class="line">   enc := json.NewEncoder(os.Stdout)</span><br><span class="line">   enc.Encode(dat)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//array 到 json str</span></span><br><span class="line">   arr := []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;python&quot;</span>, <span class="string">&quot;golang&quot;</span>, <span class="string">&quot;base&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;</span><br><span class="line">   lang, err := json.Marshal(arr)</span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;================array 到 json str==&quot;</span>)</span><br><span class="line">      fmt.Println(<span class="type">string</span>(lang))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//json 到 []string</span></span><br><span class="line">   <span class="keyword">var</span> wo []<span class="type">string</span></span><br><span class="line">   <span class="keyword">if</span> err := json.Unmarshal(lang, &amp;wo); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;================json 到 []string==&quot;</span>)</span><br><span class="line">      fmt.Println(wo)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>json</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>golang cmd命令执行</title>
    <url>/2022/03/01/golang%E6%89%A7%E8%A1%8Ccmd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>1.golang cmd命令执行<br>（１．）执行命令并获取执行结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过exec.Command函数执行命令或者shell</span></span><br><span class="line">	<span class="comment">// 第一个参数是命令路径，当然如果PATH路径可以搜索到命令，可以不用输入完整的路径</span></span><br><span class="line">	<span class="comment">// 第二到第N个参数是命令的参数</span></span><br><span class="line">	<span class="comment">// 下面语句等价于执行命令: ls -l /var/</span></span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/var/&quot;</span>)</span><br><span class="line">	<span class="comment">// 执行命令，并返回结果</span></span><br><span class="line">	output,err := cmd.Output()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 因为结果是字节数组，需要转换成string</span></span><br><span class="line">	fmt.Println(<span class="type">string</span>(output))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（２．）执行命令不返回结果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/var/&quot;</span>)</span><br><span class="line">	<span class="comment">// 执行命令，返回命令是否执行成功</span></span><br><span class="line">	err := cmd.Run()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 命令执行失败</span></span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 换行读写</title>
    <url>/2022/03/02/golang%E6%8D%A2%E8%A1%8C%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> utils</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadLines</span><span class="params">(path <span class="type">string</span>)</span></span> (lines []<span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		file   *os.File</span><br><span class="line">		part   []<span class="type">byte</span></span><br><span class="line">		prefix <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> file, err = os.Open(path); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	buffer := bytes.NewBuffer(<span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> part, prefix, err = reader.ReadLine(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		buffer.Write(part)</span><br><span class="line">		<span class="keyword">if</span> !prefix &#123;</span><br><span class="line">			lines = <span class="built_in">append</span>(lines, buffer.String())</span><br><span class="line">			buffer.Reset()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">		err = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteLines</span><span class="params">(lines []<span class="type">string</span>, path <span class="type">string</span>)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> file *os.File</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> file, err = os.Create(path); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, elem := <span class="keyword">range</span> lines &#123;</span><br><span class="line">		_, err := file.WriteString(strings.TrimSpace(elem) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 用两个栈实现队列</title>
    <url>/2022/03/15/golang%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;container/list&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := Constructor()</span><br><span class="line">	c.AppendTail(<span class="number">3</span>)</span><br><span class="line">	e := c.DeleteHead()</span><br><span class="line">	fmt.Println(e)</span><br><span class="line">	e = c.DeleteHead()</span><br><span class="line">	fmt.Println(e)</span><br><span class="line">	e = c.DeleteHead()</span><br><span class="line">	fmt.Println(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack1, stack2 *list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> CQueue &#123;</span><br><span class="line">	<span class="keyword">return</span> CQueue&#123;</span><br><span class="line">		stack1: list.New(),</span><br><span class="line">		stack2: list.New(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span></span> AppendTail(value <span class="type">int</span>) &#123;</span><br><span class="line">	this.stack1.PushBack(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span></span> DeleteHead() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> this.stack2.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> this.stack1.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			this.stack2.PushBack(this.stack1.Remove(this.stack1.Back()))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> this.stack2.Len() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> this.stack2.Remove(this.stack2.Back()).(<span class="type">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">* obj := Constructor();</span></span><br><span class="line"><span class="comment">* obj.AppendTail(value);</span></span><br><span class="line"><span class="comment">* param_2 := obj.DeleteHead();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 操作redis</title>
    <url>/2022/02/21/golang%E6%93%8D%E4%BD%9Credis/</url>
    <content><![CDATA[<p>golang操作redis库</p>
<span id="more"></span>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	OpenDB()</span><br><span class="line">	SetKeyValue(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)</span><br><span class="line">	v1, err := GetValueByValue(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v1:&quot;</span>, v1)</span><br><span class="line"></span><br><span class="line">	v2, err := GetValueByValue(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;v2:&quot;</span>, v2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenDB</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetKeyValue</span><span class="params">(key, value <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	err := rdb.Set(context.Background(), key, value, <span class="number">0</span>).Err()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetValueByValue</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	v, err := rdb.Get(context.Background(), key).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>golang远程调试</title>
    <url>/2023/04/11/golang%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="golang远程调试"><a href="#golang远程调试" class="headerlink" title="golang远程调试"></a>golang远程调试</h1><h2 id="第一步：安装go"><a href="#第一步：安装go" class="headerlink" title="第一步：安装go"></a>第一步：安装go</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载go</span></span><br><span class="line">wget https://dl.google.com/go/go1.20.3.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">tar -xzf go1.20.3.linux-amd64.tar.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">移动解压的目录到/usr/local/src目录下</span></span><br><span class="line">mv go /usr/local/src</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置环境变量</span></span><br><span class="line">export PATH=$PATH:/usr/local/src/go/bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使profile配置立即生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看go版本</span></span><br><span class="line">go version</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">若显示 go version go1.20.3 linux/amd64 则成功</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看环境变量</span></span><br><span class="line">go env </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置 goproxy</span></span><br><span class="line">go env -w GOPROXY=https://goproxy.io,direct</span><br></pre></td></tr></table></figure>

<h2 id="第二步：安装dlv"><a href="#第二步：安装dlv" class="headerlink" title="第二步：安装dlv"></a>第二步：安装dlv</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install github.com/go-delve/delve/cmd/dlv@latest</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">移动dlv工具到bin目录下</span></span><br><span class="line">mv dlv /usr/local/src/go/bin</span><br></pre></td></tr></table></figure>

<h2 id="第三步-启动dlv-实例"><a href="#第三步-启动dlv-实例" class="headerlink" title="第三步 启动dlv 实例"></a>第三步 启动dlv 实例</h2><h3 id="1、编译运行程序"><a href="#1、编译运行程序" class="headerlink" title="1、编译运行程序"></a>1、编译运行程序</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译运行文件</span></span><br><span class="line">go build -gcflags=&#x27;all -N -l&#x27; main.go</span><br></pre></td></tr></table></figure>

<ul>
<li>-N:禁止编译器优化</li>
<li>-l:关闭内联结</li>
</ul>
<h3 id="2、dlv-attach"><a href="#2、dlv-attach" class="headerlink" title="2、dlv attach"></a>2、dlv attach</h3><p>这个相当于gdb -p 或者 gdb attach ，即跟踪一个正在运行的程序。这中用法也是很常见，对于一个后台程序，它已经运行很久了，此时你需要查看程序内部的一些状态，只能借助attach.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dlv attach --headless --listen &quot;:2345&quot; --log --api-version 2  4977 ## 后面的进程的ID</span><br></pre></td></tr></table></figure>

<h3 id="3、dlv直接运行"><a href="#3、dlv直接运行" class="headerlink" title="3、dlv直接运行"></a>3、dlv直接运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dlv --listen=:2345 --headless=true --api-version=2 --accept-multiclient exec ./main</span><br></pre></td></tr></table></figure>




<h2 id="goland-远程调试"><a href="#goland-远程调试" class="headerlink" title="goland 远程调试"></a>goland 远程调试</h2><p>打开goland配置 选择go remote 填写服务器地址和端口</p>
<p><img src="/../pictures%5C1681230165886.jpg"></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang私有仓库配置</title>
    <url>/2022/08/23/golang%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>golang设置</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> env -w GOPRIVATE=<span class="string">&quot;gitlab.xxx.com/xxxx/*&quot;</span></span><br></pre></td></tr></table></figure>
<p>git设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global url.<span class="string">&quot;git@gitlab.xxxx.com:&quot;</span>.insteadOf <span class="string">&quot;http://gitlab.xxxx.com/&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go 中context的使用</title>
    <url>/2022/05/07/go%E4%B8%ADcontext%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="go中context的使用"><a href="#go中context的使用" class="headerlink" title="go中context的使用"></a>go中context的使用</h1><p>版权声明：本文为CSDN博主「Word哥」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/finghting321/article/details/106012673/">https://blog.csdn.net/finghting321/article/details/106012673/</a><br>————————————————</p>
<h2 id="1-为什么需要context"><a href="#1-为什么需要context" class="headerlink" title="1. 为什么需要context"></a>1. 为什么需要context</h2><p>在并发程序中，由于超时、取消操作或者一些异常情况，往往需要进行抢占操作或者中断后续操作。</p>
<p>举个例子：在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务，用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速中断退出，然后系统才能释放这些 goroutine 占用的资源。context深入理解可参考</p>
<span id="more"></span>
<p>context常用的使用场景：</p>
<ol>
<li>一个请求对应多个goroutine之间的数据交互</li>
<li>超时控制</li>
<li>上下文控制</li>
</ol>
<h2 id="2-context包简介"><a href="#2-context包简介" class="headerlink" title="2. context包简介"></a>2. context包简介</h2><p>context.Context接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 返回Context的超时时间（超时返回场景）</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在Context超时或取消时（即结束了）返回一个关闭的channel</span></span><br><span class="line">    <span class="comment">// 即如果当前Context超时或取消时，Done方法会返回一个channel，然后其他地方就可以通过判断Done方法是否有返回（channel），如果有则说明Context已结束</span></span><br><span class="line">    <span class="comment">// 故其可以作为广播通知其他相关方本Context已结束，请做相关处理。</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回Context取消的原因</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回Context相关数据</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承的Context，BackGound是所有Context的root，不能够被cancel。context包提供了三种context，分别是是普通context，超时context以及带值的context：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通context，通常这样调用： ctx, cancel := context.WithCancel(context.Background())</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 带超时的context，超时之后会自动close对象的Done，与调用CancelFunc的效果一样</span></span><br><span class="line"><span class="comment">// WithDeadline 明确地设置一个d指定的系统时钟时间，如果超过就触发超时</span></span><br><span class="line"><span class="comment">// WithTimeout 设置一个相对的超时时间，也就是deadline设为timeout加上当前的系统时间</span></span><br><span class="line"><span class="comment">// 因为两者事实上都依赖于系统时钟，所以可能存在微小的误差，所以官方不推荐把超时间隔设置得太小</span></span><br><span class="line"><span class="comment">// 通常这样调用：ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 带有值的context，没有CancelFunc，所以它只用于值的多goroutine传递和共享</span></span><br><span class="line"><span class="comment">// 通常这样调用：ctx := context.WithValue(context.Background(), &quot;key&quot;, myValue)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure>
<h2 id="3-场景举例—等待组"><a href="#3-场景举例—等待组" class="headerlink" title="3. 场景举例—等待组"></a>3. 场景举例—等待组</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//数据接收服务主协程同子协程同步变量</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;start 任务ID：&quot;</span>, i)</span><br><span class="line">    time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">    wg.Done() <span class="comment">// 每个goroutine运行完毕后就释放等待组的计数器</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    countThread := <span class="number">2</span> <span class="comment">//runtime.NumCPU()</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; countThread; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> run(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(countThread) <span class="comment">// 需要开启的goroutine等待组的计数器</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待所有的任务都释放</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;任务全部结束,退出&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong> </p>
<img align="left" src="http://rd7bcspti.hn-bkt.clouddn.com/02.png">  

<p><strong>分析：</strong>  对于等待组控制多并发的情况，只有所有的goroutine都结束了才算结束，只要有一个goroutine没有结束， 那么就会一直等，这显然对资源的释放是缓慢的；<br><strong>优点：</strong> 使用等待组的并发控制模型，适用于好多个goroutine协同做一件事情，因为每个goroutine做的都是这件事情的一部分，只有当全部的goroutine都完成，这件事情才算完成；<br><strong>缺点：</strong> 需要主动的通知某一个 goroutine 结束。<br><strong>疑问：</strong> 如果开启一个后台 goroutine 一直做事情，现在不需要了，那么就需要通知这个goroutine 结束，否则它会一直跑。</p>
<h2 id="4-场景举例—通道-select"><a href="#4-场景举例—通道-select" class="headerlink" title="4. 场景举例—通道+select"></a>4. 场景举例—通道+select</h2><p>针对等待组场景遗留的问题，解决办法：</p>
<blockquote>
<ol>
<li>设置全局变量，在通知goroutine要停止时，为全局变量赋值，但是这样必须保证线程安全，不可避免的必须为全局变量加锁，显得有失便利；</li>
<li>使用chan + select多路复用的方式，就会优雅许多；</li>
</ol>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(stop <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">            fmt.Println(<span class="string">&quot;任务1结束退出&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;任务1正在运行中&quot;</span>)</span><br><span class="line">            time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> run(stop) <span class="comment">// 开启goroutine</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 运行一段时间后停止</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;停止任务1。。。&quot;</span>)</span><br><span class="line">    stop &lt;- <span class="literal">true</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/upload/2022/05/image-1651908425418.png" alt="image-1651908425418"><br><strong>优点：</strong> 优雅、简单<br><strong>不足：</strong> 如果有很多 goroutine 都需要控制结束，并且这些 goroutine 又开启其它更多的goroutine ？</p>
<h2 id="5-场景举例—普通context"><a href="#5-场景举例—普通context" class="headerlink" title="5. 场景举例—普通context"></a>5. 场景举例—普通context</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context, id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Printf(<span class="string">&quot;任务%v结束退出\n&quot;</span>, id)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;任务%v正在运行中\n&quot;</span>, id)</span><br><span class="line">            time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//管理启动的协程</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="comment">// 开启多个goroutine，传入ctx</span></span><br><span class="line">    <span class="keyword">go</span> run(ctx, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> run(ctx, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 运行一段时间后停止</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;停止任务1&quot;</span>)</span><br><span class="line">    cancel() <span class="comment">// 使用context的cancel函数停止goroutine</span></span><br><span class="line">    <span class="comment">// 为了检测监控过是否停止，如果没有监控输出，表示停止</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> context.Background() 返回一个空的 Context，这个空的 Context 一般用于整个 Context 树的根节点。然后使用 context.WithCancel(parent) 函数，创建一个可取消的子 Context，然后当作参数传给 goroutine 使用，这样就可以使用这个子 Context 跟踪这个 goroutine。</p>
<p><strong>运行结果：</strong><br><img src="/upload/2022/05/image-1651908618179.png" alt="image-1651908618179"></p>
<h2 id="6-场景举例—Context超时"><a href="#6-场景举例—Context超时" class="headerlink" title="6. 场景举例—Context超时"></a>6. 场景举例—Context超时</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coroutine</span><span class="params">(ctx context.Context, duration time.Duration, id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Printf(<span class="string">&quot;协程 %d 退出\n&quot;</span>, id)</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">            fmt.Printf(<span class="string">&quot;消息来自协程 %d\n&quot;</span>, id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用WaitGroup等待所有的goroutine执行完毕，在收到&lt;-ctx.Done()的终止信号后使wg中需要等待的goroutine数量减一。</span></span><br><span class="line">    <span class="comment">// 因为context只负责取消goroutine，不负责等待goroutine运行，所以需要配合一点辅助手段</span></span><br><span class="line">    <span class="comment">//管理启动的协程</span></span><br><span class="line">    wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> coroutine(ctx, <span class="number">1</span>*time.Second, i, wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> 代码中使用WaitGroup等待所有的goroutine执行完毕，在收到&lt;-ctx.Done()的终止信号后使wg中需要等待的goroutine数量减一， 因为context只负责取消goroutine，不负责等待goroutine运行，需要配合一点辅助手段<br><strong>运行结果：</strong> </p>
<p><img src="/upload/2022/05/image-1651908781361.png" alt="image-1651908781361"></p>
<h2 id="7-场景举例—Context传递元数据"><a href="#7-场景举例—Context传递元数据" class="headerlink" title="7. 场景举例—Context传递元数据"></a>7. 场景举例—Context传递元数据</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> key <span class="type">string</span> = <span class="string">&quot;name&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Printf(<span class="string">&quot;任务%v结束退出\n&quot;</span>, ctx.Value(key))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;任务%v正在运行中\n&quot;</span>, ctx.Value(key))</span><br><span class="line">            time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//管理启动的协程</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="comment">// 给ctx绑定键值，传递给goroutine</span></span><br><span class="line">    valuectx := context.WithValue(ctx, key, <span class="string">&quot;【监控1】&quot;</span>)</span><br><span class="line">    <span class="comment">// 开启goroutine，传入ctx</span></span><br><span class="line">    <span class="keyword">go</span> run(valuectx)</span><br><span class="line">    <span class="comment">// 运行一段时间后停止</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;停止任务&quot;</span>)</span><br><span class="line">    cancel() <span class="comment">// 使用context的cancel函数停止goroutine</span></span><br><span class="line">    <span class="comment">// 为了检测监控过是否停止，如果没有监控输出，表示停止</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong><br><img src="/upload/2022/05/image-1651908878817.png" alt="image-1651908878817"></p>
<h2 id="8-context总结"><a href="#8-context总结" class="headerlink" title="8. context总结"></a>8. context总结</h2><blockquote>
<ol>
<li>不要把 Context 放在结构体中，要以参数的方式传递</li>
<li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位</li>
<li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO</li>
<li>Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递</li>
<li>Context 是线程安全的，可以放心的在多个 goroutine 中传递</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go 中 new和make的区别</title>
    <url>/2022/05/07/go%E4%B8%ADnew%E5%92%8Cmake%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="go中new和make的区别"><a href="#go中new和make的区别" class="headerlink" title="go中new和make的区别"></a>go中new和make的区别</h1><p>new和make是用于go中分配内存的，简单来说，new只分配内存，make用于初始化slice、map以及channel。</p>
<p>Go语言中的 new 和 make 主要区别如下：<br>make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；<br>new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；<br>new 分配的空间被清零。make 分配空间后，会进行初始化；</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 命令行配置代理</title>
    <url>/2022/02/16/linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="命令行配置代理"><a href="#命令行配置代理" class="headerlink" title="命令行配置代理"></a>命令行配置代理</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:1087</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$http_proxy</span></span><br></pre></td></tr></table></figure>

<h2 id="此处的IP和端口需要根据具体你代理的实际信息填写，可查看VPN客户端的config-json"><a href="#此处的IP和端口需要根据具体你代理的实际信息填写，可查看VPN客户端的config-json" class="headerlink" title="此处的IP和端口需要根据具体你代理的实际信息填写，可查看VPN客户端的config.json"></a>此处的IP和端口需要根据具体你代理的实际信息填写，可查看VPN客户端的config.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;inbounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;listen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;socks&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;udp&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span> <span class="string">&quot;noauth&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1080&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;listen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;protocol&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">360</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1087&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>检查命令行配置是否完成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -i www.google.com</span><br></pre></td></tr></table></figure>

<p>收到200响应表示成功</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>代理</tag>
        <tag>linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 配置多个域名对应不同端口</title>
    <url>/2022/03/11/nginx%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E5%AF%B9%E5%BA%94%E4%B8%8D%E5%90%8C%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="nginx-多个域名不同端口"><a href="#nginx-多个域名不同端口" class="headerlink" title="nginx 多个域名不同端口"></a>nginx 多个域名不同端口</h1><h2 id="首先准备三个域名和端口"><a href="#首先准备三个域名和端口" class="headerlink" title="首先准备三个域名和端口"></a>首先准备三个域名和端口</h2><ul>
<li>carrotvegeta.icu  80</li>
<li>blog.carrotvegeta.icu 8090</li>
<li>email.carrotvegeta.icu 8080<span id="more"></span>
<h2 id="1、写在一个配置文件里面（nginx-conf）："><a href="#1、写在一个配置文件里面（nginx-conf）：" class="headerlink" title="1、写在一个配置文件里面（nginx.conf）："></a>1、写在一个配置文件里面（nginx.conf）：</h2></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name carrotvegeta.icu;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        proxy_pass http://localhost:80;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##### other directive</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.carrotvegeta.icu;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        proxy_pass http://localhost:8090;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##### other directive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要再继续增加就再增加一个server</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name carrotvegeta.icu;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        proxy_pass http://localhost:80;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##### other directive</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.carrotvegeta.icu;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        proxy_pass http://localhost:8090;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##### other directive</span></span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name email.carrotvegeta.icu;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##### other directive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、写在多个配置文件里面"><a href="#2、写在多个配置文件里面" class="headerlink" title="2、写在多个配置文件里面"></a>2、写在多个配置文件里面</h2><p>  当我们的域名变的非常多的时候，就需要一直不断的在一个配置文件里面增加server，这样就会变得越来越多导致不太好管理。<br>  nginx支持引入文件的方法，这时我们可以在其他地方新建好我们所需要的配置文件:</p>
<p>blog.conf：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.carrotvegeta.icu;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        proxy_pass http://localhost:8090;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##### other directive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>email.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name email.carrotvegeta.icu;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##### other directive</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把两个文件都放在&#x2F;data&#x2F;nginx&#x2F;conf&#x2F;vhost目录下。</p>
<p>然后在nginx.conf中使用引入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include  /data/nginx/conf/vhost/*.conf;即可。</span><br></pre></td></tr></table></figure>
<p>需要注意的是这句命令应该放在：http{}  的花括号内。因为include的命令引入相当于被引入的所有代码写在nginx.conf中一样。</p>
<p>配置nginx.conf文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  include /data/nginx/conf/vhost/*.conf;</span><br><span class="line"></span><br><span class="line">  server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name carrotvegeta.icu;</span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        proxy_pass http://localhost:80;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">##### other directive</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重启ngxin:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>原文地址：<a href="https://www.cnblogs.com/goloving/p/9363490.html">https://www.cnblogs.com/goloving/p/9363490.html</a></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 启动停止命令</title>
    <url>/2022/04/06/nginx%20%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h1><p>启动服务：systemctl start nginx</p>
<p>关闭服务： systemctl stop nginx</p>
<p>重载配置：systemctl reload nginx</p>
<p>重启服务：systemctl restart nginx</p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 命令行备份数据</title>
    <url>/2022/02/16/mysql%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/gcixx/">桄椿</a></p>
<h2 id="mysql命令行备份方法"><a href="#mysql命令行备份方法" class="headerlink" title="mysql命令行备份方法"></a><a href="https://www.cnblogs.com/gcixx/p/11145473.html">mysql命令行备份方法</a></h2><p>一、mysql备份</p>
<p>1、备份命令</p>
<p>格式：mysqldump -h主机IP -P端口 -u用户名 -p密码 –database 数据库名 &gt; 文件名.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 本地备份可以不添加端口和主机IP，username、passward是数据库用户名和密码</span><br><span class="line">mysqldump -h *.*.*.* -p 3306 -u username -p password --database mysql &gt; /data/backup/mysql.sql</span><br></pre></td></tr></table></figure>

<p>2、备份压缩</p>
<p>格式：mysqldump -h主机IP -P端口 -u用户名 -p密码 –database 数据库名 | gzip &gt; 文件名.sql.gz</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导出的数据有可能比较大，不好备份到远程，这时候就需要进行压缩</span><br><span class="line">mysqldump -h *.*.*.* -p 3306 -u username -p password --database mysql | gzip &gt; /data/backup/mysql.sql.gz</span><br></pre></td></tr></table></figure>

<p>3、备份同个库多个表</p>
<p>格式：mysqldump -h主机IP -P端口 -u用户名 -p密码 –database 数据库名 表1 表2 …. &gt; 文件名.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -h *.*.*.* -p 3306 -u username -p password mysql1 mysql2 mysql3&gt; /data/backup/mysql_db.sql</span><br></pre></td></tr></table></figure>

<p>4、同时备份多个库</p>
<p>格式：mysqldump -h主机IP -P端口 -u用户名 -p密码 –databases 数据库名1 数据库名2 数据库名3 &gt; 文件名.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -h *.*.*.* -p 3306 -u username -p password --databases mysql1 mysql2 mysql3 &gt; /data/backup/mysql_db.sql</span><br></pre></td></tr></table></figure>

<p>5、备份实例上所有的数据库</p>
<p>格式：mysqldump -h主机IP -P端口 -u用户名 -p密码 –all-databases &gt; 文件名.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -h *.*.*.* -p 3306 -u username -p password --all-databases &gt; /data/backup/mysql_db.sql</span><br></pre></td></tr></table></figure>

<p>6、备份数据出带删除数据库或者表的sql备份</p>
<p>格式：mysqldump -h主机IP -P端口 -u用户名 -p密码 –add-drop-table –add-drop-database 数据库名 &gt; 文件名.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -h *.*.*.* -p 3306 -u username -p password --add-drop-table --add-drop-database mysql &gt; /data/backup/mysql_db.sql</span><br></pre></td></tr></table></figure>

<p>7、备份数据库结构，不备份数据</p>
<p>格式：mysqldump -h主机IP -P端口 -u用户名 -p密码 –no-data 数据库名1 数据库名2 数据库名3 &gt; 文件名.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -h *.*.*.* -p 3306 -u username -p password --no-data –databases mysql1 mysql2 mysql3 &gt; /data/backup/structure_db.sql</span><br></pre></td></tr></table></figure>

<p>8、还原MySQL数据库的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># database为数据库名</span><br><span class="line">mysql -h *.*.*.* -u username -p password database &lt; backupfile.sql</span><br></pre></td></tr></table></figure>

<p>9、还原压缩的MySQL数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># database为数据库名</span><br><span class="line">gunzip &lt; backupfile.sql.gz | mysql -u username -p password database</span><br></pre></td></tr></table></figure>

<p>10、将数据库转移到新服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># database为数据库名</span><br><span class="line">mysqldump -u username -p password database | mysql –host=*.*.*.* -C database</span><br></pre></td></tr></table></figure>

<p>11、–master-data 和–single-transaction</p>
<p> 在mysqldump中使用–master-data&#x3D;2，会记录binlog文件和position的信息 。</p>
<p> –single-transaction会将隔离级别设置成repeatable-commited。</p>
<p>12、导入数据库</p>
<p> 常用source命令，用use进入到某个数据库，mysql&gt;source d:\test.sql，后面的参数为脚本文件。</p>
<p>13、查看binlog日志</p>
<p> 查看binlog日志可用命令 mysqlbinlog binlog日志名称|more</p>
<p>14、general_log</p>
<p> General_log记录数据库的任何操作，查看general_log 的状态和位置可以用命令show variables like “general_log%” ,开启general_log可以用命令set global general_log&#x3D;on</p>
<p>二、增量备份</p>
<p>1、首先做一次完整备份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这时候就会得到一个全备文件test.sql</span><br><span class="line">mysqldump -h *.*.*.* -u username -p passward  -p 3310 --single-transaction  --master-data=2  test&gt;test.sql</span><br></pre></td></tr></table></figure>

<p>在sql文件中我们会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 是指备份后所有的更改将会保存到bin-log.000002二进制文件中。</span><br><span class="line">CHANGE MASTER TO MASTER_LOG_FILE=&#x27;bin-log.000002&#x27;, MASTER_LOG_POS=107;</span><br></pre></td></tr></table></figure>

<p>2、在test库的t_student表中增加两条记录，然后执行flush logs命令。</p>
<p> 这时将会产生一个新的二进制日志文件bin-log.000003，bin-log.000002则保存了全备过后的所有更改，既增加记录的操作也保存在了bin-log.00002中。</p>
<p>3、再在test库中的a表中增加两条记录，然后误删除t_student表和a表。</p>
<p> a中增加记录的操作和删除表a和t_student的操作都记录在bin-log.000003中。</p>
<h2 id="三、恢复"><a href="#三、恢复" class="headerlink" title="三、恢复"></a>三、恢复</h2><p>1、首先导入全备数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 也可以直接在mysql命令行下面用source导入</span><br><span class="line">mysql -h *.*.*.* -u username -p passward  -p 3310 &lt; test.sql</span><br></pre></td></tr></table></figure>

<p>2、恢复bin-log.000002</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog bin-log.000002 |mysql -h *.*.*.* -u username -p passward -p 3310</span><br></pre></td></tr></table></figure>

<p>3、恢复部分 bin-log.000003</p>
<p>在general_log中找到误删除的时间点，然后更加对应的时间点到bin-log.000003中找到相应的position点，需要恢复到误删除的前面一个position点。</p>
<p>可以用如下参数来控制binlog的区间</p>
<p>–start-position 开始点 –stop-position 结束点</p>
<p>–start-date 开始时间 –stop-date 结束时间</p>
<p>找到恢复点后，既可以开始恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysql-bin.000003 --stop-position=208 |mysql -h *.*.*.* -u username -p passward -p 3310 </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>备份</tag>
        <tag>恢复</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 基本命令</title>
    <url>/2022/03/11/nginx%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="nginx基本命令"><a href="#nginx基本命令" class="headerlink" title="nginx基本命令"></a>nginx基本命令</h1><p>1、启动：<br>使用默认nginx.conf来启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure>
<p>如果要指定配置文件来启动则使用以下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -c ./conf/jason.conf</span><br></pre></td></tr></table></figure>
<p>2、关闭：</p>
<p>快速关闭nginx服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure>
<p>优雅的关闭,优雅是指当一个请求被处理完成之后才被关闭。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>

<p>3、配置语法检查：可进行配置文件的语法检测。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -c ./conf/jason.conf -t</span><br></pre></td></tr></table></figure>
<p>4、查看nginx版本信息：-v和-V，一个小写v，一个大写V，两个的含义有些不同。</p>
<p>nginx -v:只是显示nginx的当前版本,如下图</p>
<p><img src="/upload/2022/03/image-649783c8200a4d018e2558a7976cc38d.png" alt="image.png"></p>
<p>nginx -V：显示nginx版本、编译器版本和配置参数信息，如下图</p>
<p><img src="/upload/2022/03/image-61236735bba34682926b603790610f4c.png" alt="image.png"></p>
<p>5、重新加载配置文件，nginx是支持热部署的，意思就是可以在不停止服务的情况下进行更新部署。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload </span><br></pre></td></tr></table></figure>
<p>6、linux命令重启<br>查找当前nginx进程号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure>
<p>然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP 进程号</span><br></pre></td></tr></table></figure>
<p>实现重启nginx服务</p>
<p>7、重新打开日志文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reopen</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh隧道-能ssh就能http和tcp，通过ssh就能访问内网web页面和数据库</title>
    <url>/2022/03/29/ssh%E9%9A%A7%E9%81%93-%E8%83%BDssh%E5%B0%B1%E8%83%BDhttp%E5%92%8Ctcp%EF%BC%8C%E9%80%9A%E8%BF%87ssh%E5%B0%B1%E8%83%BD%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91web%E9%A1%B5%E9%9D%A2%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>出于安全考虑，一般云主机都只能通过堡垒机两级ssh才能连通，即先ssh堡垒机，再ssh连到内网目标云主机上执行命令。<br>(堡垒机俗称跳板机，一般只开放一个ssh端口。有些堡垒机没有公网IP，必须先登录vpn能才能连)</p>
<p>怎么传文件呢？<br>先传到跳板机再传到目标机？传2次？太麻烦，浪费时间还浪费磁盘空间。<br>有人说配置config，可以直接ssh目标机，也可以直接scp文件到目标机。没错是这样（文中有配置示例）。</p>
<p>那云主机上有web页面能直接访问么？</p>
<ul>
<li>内网数据库能直接连么？<br>当然可以的，能连ssh，就能访问内网的网页和数据库。只要能手动多级ssh访问到，就能通过配置ssh后在本地直接访问到。<span id="more"></span>
轻松实现<br>假设网络条件如下：（受安全组或网络策略影响，只能通过10.20.20.20访问192.168.88.8:8888）</li>
</ul>
<blockquote>
<p>本机（登录VPN 公网IP:8444） –&gt; 10.10.10.10:22 –&gt; 10.20.20.20:22 –&gt;<br>192.168.88.8:8888</p>
</blockquote>
<p>只需3步：</p>
<ol>
<li>本机配置ssh跳板。保证本机能直接ssh 10.20.20.20。因为跳板机10不能访问目标8888端口</li>
<li>在命令行中（推荐GitBash）执行如下命令，输入20的账号密码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -f -N -L localhost:12345:192.168.88.8:8888 user@10.20.20.20 -p22</span><br></pre></td></tr></table></figure></li>
<li>在本机浏览器中输入localhost:12345，出来的就是目标机8888端口的内容。<h2 id="配置ssh跳板"><a href="#配置ssh跳板" class="headerlink" title="配置ssh跳板"></a>配置ssh跳板</h2>配置本机直接ssh 10.20.20.20。配置示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi <span class="variable">$HOME</span>/.ssh/config</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host jumper</span><br><span class="line">  hostname 10.10.10.10 <span class="comment">#跳板机要装有ncat，否则连接时会报错</span></span><br><span class="line">Host sub2020</span><br><span class="line">  hostname 10.20.20.*</span><br><span class="line">  ProxyCommand ssh -q -A jumper nc %h %p</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>当然如果8888是数据库端口，也是直接在数据库客户中配置地址为localhost:12345。</li>
<li>当然10.10.10.10，10.20.20.20也可以配置免密登录，不用再输密码<h2 id="再引申一下，还想让其他ip通过本机直连内网页面"><a href="#再引申一下，还想让其他ip通过本机直连内网页面" class="headerlink" title="再引申一下，还想让其他ip通过本机直连内网页面"></a>再引申一下，还想让其他ip通过本机直连内网页面</h2><blockquote>
<p>其他IP –&gt; 本机IP:12345（登录VPN 公网IP:8444） –&gt; 10.10.10.10:22 –&gt;<br>192.168.88.8:8888</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -f -N -L 本机IP:12345:192.168.88.8:8888 user@10.10.10.10 -p22</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -f -N -L :12345:192.168.88.8:8888 user@10.10.10.10 -p22</span><br></pre></td></tr></table></figure></li>
<li>注意前提是要保证本机的防火墙已放通12345端口，这样别人才能连通本机的12345端口<br>再简单一点，目标服务就在跳板机上，但是端口未放开（只放开22）</li>
</ul>
<blockquote>
<p>本机 –&gt; 10.10.10.10:22 –&gt; 10.10.10.10:8888</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -f -N -L :12345:10.10.10.10:8888 user@10.10.10.10 -p22</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/liliwang90/article/details/123153893">原文地址</a></p>
]]></content>
      <categories>
        <category>ssh</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>不需要运行进入docker 容器</title>
    <url>/2022/03/31/%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%90%E8%A1%8C%E9%87%91%E8%9E%8Ddocker%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="不需要运行进入docker-容器"><a href="#不需要运行进入docker-容器" class="headerlink" title="不需要运行进入docker 容器"></a>不需要运行进入docker 容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it 镜像<span class="built_in">id</span> /bin/bash</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用rsync命令</title>
    <url>/2022/02/16/%E4%BD%BF%E7%94%A8rsync%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="本地上传至远程"><a href="#本地上传至远程" class="headerlink" title="本地上传至远程"></a>本地上传至远程</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -av localPath username@ip:remotepath</span><br></pre></td></tr></table></figure>

<ul>
<li><p>–progress 参数 可显示进度条</p>
</li>
<li><p>-azvrtopg 增量更新</p>
</li>
<li><p>–exclude&#x3D;’path’ 忽略文件夹或某个文件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title>使用scp命令传输文件到服务器</title>
    <url>/2022/02/15/%E4%BD%BF%E7%94%A8scp%E5%91%BD%E4%BB%A4%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="使用scp命令"><a href="#使用scp命令" class="headerlink" title="使用scp命令"></a>使用scp命令</h1><p>上传本地文件到服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /path/filename username@servername:/path/</span><br></pre></td></tr></table></figure>

<p>从服务器上下载文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp username@servername:/path/filename /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure>

<p>从服务器下载整个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure>

<p>上传目录到服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r local_dir username@servername:remote_dir</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>单纯启动docker容器不启动服务</title>
    <url>/2022/02/16/%E5%8D%95%E7%BA%AF%E5%90%AF%E5%8A%A8docker%E5%AE%B9%E5%99%A8%E4%B8%8D%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -itd --name spp 镜像名:标签 bash</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>获取项目中 golang 代码行数</title>
    <url>/2022/03/10/%E8%8E%B7%E5%8F%96%E9%A1%B9%E7%9B%AE%E4%B8%AD%20golang%20%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/</url>
    <content><![CDATA[<p>获取包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/hhatto/gocloc/cmd/gocloc</span><br></pre></td></tr></table></figure>
<p>在项目下执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gocloc  ./</span><br></pre></td></tr></table></figure>
<p><img src="/upload/2022/03/image-8779d8ceda504a4e96579fa4fcb26844.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用高阶函数编程提升代码的简洁性</title>
    <url>/2022/02/24/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%E6%8F%90%E5%8D%87%E4%BB%A3%E7%A0%81%E7%9A%84%E7%AE%80%E6%B4%81%E6%80%A7/</url>
    <content><![CDATA[<p>摘要<br>函数是 Go 语言的一等公民，本文采用一种高阶函数的方式，抽象了使用 gorm 查询 DB 的查询条件，将多个表的各种复杂的组合查询抽象成了一个统一的方法和一个配置类，提升了代码的简洁和优雅，同时可以提升开发人员的效率。</p>
<span id="more"></span>
<p>背景<br>有一张 DB 表，业务上需要按照这个表里的不同字段做筛选查询，这是一个非常普遍的需求，我相信这种需求对于每个做业务开发的人都是绕不开的。比如我们有一张存储用户信息的表，简化之后的表结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user_info` (</span><br><span class="line">  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">  `user_id` bigint NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">  `user_name` varchar NOT NULL COMMENT &#x27;用户姓名&#x27;,</span><br><span class="line">  `role` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;角色&#x27;,</span><br><span class="line">  `status` int NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;状态&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户信息表&#x27;;</span><br></pre></td></tr></table></figure>
<p>这个表里有几个关键字段，user_id、user_name 、 role、status。如果我们想按照 user_id 来做筛选，那我们一般是在 dao 层写一个这样的方法(为了示例代码的简洁，这里所有示例代码都省去了错误处理部分)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfoByUid</span><span class="params">(ctx context.Context, userID <span class="type">int64</span>)</span></span> ([]*resource.UserInfo) &#123;</span><br><span class="line">   db := GetDB(ctx)</span><br><span class="line">   db = db.Table(resource.UserInfo&#123;&#125;.TableName())</span><br><span class="line">   <span class="keyword">var</span> infos []*resource.UserInfo</span><br><span class="line">   db = db.Where(<span class="string">&quot;user_id = ?&quot;</span>, userID)</span><br><span class="line">   db.Find(&amp;infos)</span><br><span class="line">   <span class="keyword">return</span> infos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果业务上又需要按照 user_name 来查询，那我们就需要再写一个类似的方法按照 user_name 来查询：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfoByName</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span> ([]*resource.UserInfo) &#123;</span><br><span class="line">   db := GetDB(ctx)</span><br><span class="line">   db = db.Table(resource.UserInfo&#123;&#125;.TableName())</span><br><span class="line">   <span class="keyword">var</span> infos []*resource.UserInfo</span><br><span class="line">   db = db.Where(<span class="string">&quot;user_name = ?&quot;</span>, name)</span><br><span class="line">   db.Find(&amp;infos)</span><br><span class="line">   <span class="keyword">return</span> infos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，两个方法的代码极度相似，如果再需要按照 role 或者 status 查询，那不得不再来几个方法，导致相似的方法非常多。当然很容易想到，我们可以用一个方法，多几个入参的形式来解决这个问题，于是，我们把上面两个方法合并成下面这种方法，能够支持按照多个字段筛选查询：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(ctx context.Context, userID <span class="type">int64</span>, name <span class="type">string</span>, role <span class="type">int</span>, status <span class="type">int</span>)</span></span> ([]*resource.UserInfo) &#123;</span><br><span class="line">   db := GetDB(ctx)</span><br><span class="line">   db = db.Table(resource.UserInfo&#123;&#125;.TableName())</span><br><span class="line">   <span class="keyword">var</span> infos []*resource.UserInfo</span><br><span class="line">   <span class="keyword">if</span> userID &gt; <span class="number">0</span> &#123;</span><br><span class="line">      db = db.Where(<span class="string">&quot;user_id = ?&quot;</span>, userID)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      db = db.Where(<span class="string">&quot;user_name = ?&quot;</span>, name)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> role &gt; <span class="number">0</span> &#123;</span><br><span class="line">      db = db.Where(<span class="string">&quot;role = ?&quot;</span>, role)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> status &gt; <span class="number">0</span> &#123;</span><br><span class="line">      db = db.Where(<span class="string">&quot;status = ?&quot;</span>, status)</span><br><span class="line">   &#125;</span><br><span class="line">   db.Find(&amp;infos)</span><br><span class="line">   <span class="keyword">return</span> infos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应地，调用该方法的代码也需要做出改变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只根据UserID查询</span></span><br><span class="line">infos := GetUserInfo(ctx, userID, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//只根据UserName查询</span></span><br><span class="line">infos := GetUserInfo(ctx, <span class="number">0</span>, name, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//只根据Role查询</span></span><br><span class="line">infos := GetUserInfo(ctx, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, role, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//只根据Status查询</span></span><br><span class="line">infos := GetUserInfo(ctx, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="number">0</span>, status)</span><br></pre></td></tr></table></figure>
<p>这种代码无论是写代码的人还是读代码的人，都会感觉非常难受。我们这里只列举了四个参数，可以想想这个表里如果有十几个到二十个字段都需要做筛选查询，这种代码看上去是一种什么样的感觉。首先，GetUserInfo 方法本身入参非常多，里面充斥着各种 !&#x3D; 0 和 !&#x3D; “”的判断，并且需要注意的是，0 一定不能作为字段的有效值，否则 !&#x3D; 0 这种判断就会有问题。其次，作为调用方，明明只是根据一个字段筛选查询，却不得不为其他参数填充一个 0 或者””来占位，而且调用者要特别谨慎，因为一不小心，就可能会把 role 填到了 status 的位置上去，因为他们的类型都一样，编译器不会检查出任何错误，很容易搞出业务 bug。</p>
<p>解决方案<br>如果说解决这种问题有段位，那么以上的写法只能算是青铜，接下来我们看看白银、黄金和王者。</p>
<p>白银<br>解决这种问题，一种比较常见的方案是，新建一个结构体，把各种查询的字段都放在这个结构体中，然后把这个结构体作为入参传入到 dao 层的查询方法中。而在调用 dao 方法的地方，根据各自的需要，构建包含不同字段的结构体。在这个例子中，我们可以构建一个 UserInfo 的结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">   UserID <span class="type">int64</span></span><br><span class="line">   Name <span class="type">string</span></span><br><span class="line">   Role <span class="type">int32</span></span><br><span class="line">   Status <span class="type">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 UserInfo 作为入参传给 GetUserInfo 方法，于是 GetUserInfo 方法变成了这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(ctx context.Context, info *UserInfo)</span></span> ([]*resource.UserInfo) &#123;</span><br><span class="line">   db := GetDB(ctx)</span><br><span class="line">   db = db.Table(resource.UserInfo&#123;&#125;.TableName())</span><br><span class="line">   <span class="keyword">var</span> infos []*resource.UserInfo</span><br><span class="line">   <span class="keyword">if</span> info.UserID &gt; <span class="number">0</span> &#123;</span><br><span class="line">      db = db.Where(<span class="string">&quot;user_id = ?&quot;</span>, info.UserID)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> info.Name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      db = db.Where(<span class="string">&quot;user_name = ?&quot;</span>, info.Name)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> info.Role &gt; <span class="number">0</span> &#123;</span><br><span class="line">      db = db.Where(<span class="string">&quot;role = ?&quot;</span>, info.Role)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> info.Status &gt; <span class="number">0</span> &#123;</span><br><span class="line">      db = db.Where(<span class="string">&quot;status = ?&quot;</span>, info.Status)</span><br><span class="line">   &#125;</span><br><span class="line">   db.Find(&amp;infos)</span><br><span class="line">   <span class="keyword">return</span> infos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应地，调用该方法的代码也需要变动：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只根据userD查询</span></span><br><span class="line">info := &amp;UserInfo&#123;</span><br><span class="line">   UserID: userID,</span><br><span class="line">&#125;</span><br><span class="line">infos := GetUserInfo(ctx, info)</span><br><span class="line"><span class="comment">//只根据name查询</span></span><br><span class="line">info := &amp;UserInfo&#123;</span><br><span class="line">   Name: name,</span><br><span class="line">&#125;</span><br><span class="line">infos := GetUserInfo(ctx, info)</span><br></pre></td></tr></table></figure>
<p>这个代码写到这里，相比最开始的方法其实已经好了不少，至少 dao 层的方法从很多个入参变成了一个，调用方的代码也可以根据自己的需要构建参数，不需要很多空占位符。但是存在的问题也比较明显：仍然有很多判空不说，还引入了一个多余的结构体。如果我们就到此结束的话，多少有点遗憾。</p>
<p>另外，如果我们再扩展一下业务场景，我们使用的不是等值查询，而是多值查询或者区间查询，比如查询 status in (a, b)，那上面的代码又怎么扩展呢？是不是又要引入一个方法，方法繁琐暂且不说，方法名叫啥都会让我们纠结很久；或许可以尝试把每个参数都从单值扩展成数组，然后赋值的地方从 &#x3D; 改为 in()的方式，所有参数查询都使用 in 显然对性能不是那么友好。</p>
<p>黄金<br>接下来我们看看黄金的解法。在上面的方法中，我们引入了一个多余的结构体，并且无法避免在 dao 层的方法中做了很多判空赋值。那么我们能不能不引入 UserInfo 这个多余的结构体，并且也避免这些丑陋的判空？答案是可以的，函数式编程可以很好地解决这个问题，首先我们需要定义一个函数类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*gorm.DB)</span></span></span><br></pre></td></tr></table></figure>
<p>定义 Option 是一个函数，这个函数的入参类型是*gorm.DB，返回值为空。</p>
<p>然后针对 DB 表中每个需要筛选查询的字段定义一个函数，为这个字段赋值，像下面这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserID</span><span class="params">(userID <span class="type">int64</span>)</span></span> Option &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">      db.Where(<span class="string">&quot;`user_id` = ?&quot;</span>, userID)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserName</span><span class="params">(name <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">      db.Where(<span class="string">&quot;`user_name` = ?&quot;</span>, name)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Role</span><span class="params">(role <span class="type">int32</span>)</span></span> Option &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">      db.Where(<span class="string">&quot;`role` = ?&quot;</span>, role)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Status</span><span class="params">(status <span class="type">int32</span>)</span></span> Option &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">      db.Where(<span class="string">&quot;`status` = ?&quot;</span>, status)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这组代码中，入参是一个字段的筛选值，返回的是一个 Option 函数，而这个函数的功能是把入参赋值给当前的【db *gorm.DB】对象。这也就是我们在文章一开始就提到的高阶函数，跟我们普通的函数不太一样，普通的函数返回的是一个简单类型的值或者一个封装类型的结构体，而这种高阶函数返回的是一个具备某种功能的函数。这里多说一句，虽然 go 语言很好地支持了函数式编程，但是由于其目前缺少对泛型的支持，导致高阶函数编程的使用并没有给开发者带来更多的便利，因此在平时业务代码中写高阶函数还是略为少见。而熟悉 JAVA 的同学都知道，JAVA 中的 Map、Reduce、Filter 等高阶函数使用起来非常的舒服。</p>
<p>好，有了这一组函数之后，我们来看看 dao 层的查询方法怎么写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(ctx context.Context, options ...<span class="keyword">func</span>(option *gorm.DB)</span></span>) ([]*resource.UserInfo) &#123;</span><br><span class="line">   db := GetDB(ctx)</span><br><span class="line">   db = db.Table(resource.UserInfo&#123;&#125;.TableName())</span><br><span class="line">   <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">      option(db)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> infos []*resource.UserInfo</span><br><span class="line">   db.Find(&amp;infos)</span><br><span class="line">   <span class="keyword">return</span> infos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有对比就没有伤害，通过和最开始的方法比较，可以看到方法的入参由多个不同类型的参数变成了一组相同类型的函数，因此在处理这些参数的时候，也无需一个一个的判空，而是直接使用一个 for 循环就搞定，相比之前已经简洁了很多。</p>
<p>那么调用该方法的代码怎么写呢，这里直接给出来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只使用userID查询</span></span><br><span class="line">infos := GetUserInfo(ctx, UserID(userID))</span><br><span class="line"><span class="comment">//只使用userName查询</span></span><br><span class="line">infos := GetUserInfo(ctx, UserName(name))</span><br><span class="line"><span class="comment">//使用role和status同时查询</span></span><br><span class="line">infos := GetUserInfo(ctx, Role(role), Status(status))</span><br></pre></td></tr></table></figure>
<p>无论是使用任意的单个参数还是使用多个参数组合查询，我们都随便写，不用关注参数顺序，简洁又清晰，可读性也是非常好。</p>
<p>再来考虑上面提到的扩展场景，如果我们需要多值查询，比如查询多个 status，那么我们只需要在 Option 中增加一个小小的函数即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StatusIn</span><span class="params">(status []<span class="type">int32</span>)</span></span> Option &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">      db.Where(<span class="string">&quot;`status` in ?&quot;</span>, status)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于其他字段或者等值查询也是同理，代码的简洁不言而喻。</p>
<p>王者<br>能优化到上面黄金的阶段，其实已经很简洁了，如果止步于此的话，也是完全可以的。但是如果还想进一步追求极致，那么请继续往下看！</p>
<p>在上面方法中，我们通过高阶函数已经很好地解决了对于一张表中多字段组合查询的代码繁琐问题，但是对于不同的表查询，仍然要针对每个表都写一个查询方法，那么还有没有进一步优化的空间呢？我们发现，在 Option 中定义的这一组高阶函数，压根与某张表没关系，他只是简单地给 gorm.DB 赋值。因此，如果我们有多张表，每个表里都有 user_id、is_deleted、create_time、update_time 这些公共的字段，那么我们完全不用再重复定义一次，只需要在 Option 中定义一个就够了，每张表的查询都可以复用这些函数。进一步思考，我们发现，Option 中维护的是一些傻瓜式的代码，根本不需要我们每次手动去写，可以使用脚本生成，扫描一遍 DB 的表，为每个不重复的字段生成一个 Equal 方法、In 方法、Greater 方法、Less 方法，就可以解决所有表中按照不同字段做等值查询、多值查询、区间查询。</p>
<p>解决了 Option 的问题之后，对于每个表的各种组合查询，就只需要写一个很简单的 Get 方法了，为了方便看，我们在这里再贴一次：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserInfo</span><span class="params">(ctx context.Context, options ...<span class="keyword">func</span>(option *gorm.DB)</span></span>) ([]*resource.UserInfo) &#123;</span><br><span class="line">   db := GetDB(ctx)</span><br><span class="line">   db = db.Table(resource.UserInfo&#123;&#125;.TableName())</span><br><span class="line">   <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">      option(db)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> infos []*resource.UserInfo</span><br><span class="line">   db.Find(&amp;infos)</span><br><span class="line">   <span class="keyword">return</span> infos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个查询方法是针对 user_info 这个表写的，如果还有其他表，我们还需要为每个表都写一个和这个类似的 Get 方法。如果我们仔细观察每个表的 Get 方法，会发现这些方法其实就有两点不同：</p>
<p>返回值类型不一样；<br>TableName 不一样。<br>如果我们能解决这两个问题，那我们就能够使用一个方法解决所有表的查询。首先对于第一点返回值不一致的问题，可以参考 json.unmarshal 的做法，把返回类型以一个参数的形式传进来，因为传入的是指针类型，所以就不用再给返回值了；而对于 tableName 不一致的问题，其实可以和上面处理不同参数的方式一样，增加一个 Option 方法来解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TableName</span><span class="params">(tableName <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> &#123;</span><br><span class="line">      db.Table(tableName)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改造之后，我们的 dao 层查询方法就变成了这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetRecord</span><span class="params">(ctx context.Context, in <span class="keyword">interface</span>&#123;&#125;, options ...<span class="keyword">func</span>(option *gorm.DB)</span></span>) &#123;</span><br><span class="line">   db := GetDB(ctx)</span><br><span class="line">   <span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">      option(db)</span><br><span class="line">   &#125;</span><br><span class="line">   db.Find(in)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，我们把方法名从之前的 GetUserInfo 变成了GetRecord，因为这个方法不仅能支持对于 user_info 表的查询，而且能够支持对一个库中所有表的查询。也就是说从最开始为每个表建一个类，每个类下面又写很多个查询方法，现在变成了所有表所有查询适用一个方法。</p>
<p>然后我们看看调用这个方法的代码怎么写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据userID和userName查询</span></span><br><span class="line"><span class="keyword">var</span> infos []*resource.UserInfo</span><br><span class="line">GetRecord(ctx, &amp;infos, TableName(resource.UserInfo&#123;&#125;.TableName()), UserID(userID), UserName(name))</span><br></pre></td></tr></table></figure>
<p>这里还是给出了查询 user_info 表的示例，在调用的地方指定 tableName 和返回类型。</p>
<p>经过这样的改造之后，我们最终实现了用一个简单的方法【GetRecord】 + 一个可自动生成的配置类【Option】对一个库中所有表的多种组合查询。代码的简洁和优雅又有了一些提升。美中不足的是，在调用查询方法的地方多传了两个参数，一个是返回值变量，一个是 tableName，多少显得有点不那么美观。</p>
<p>总结<br>这里通过对 grom 查询条件的抽象，大大简化了对 DB 组合查询的写法，提升了代码的简洁。对于其他 update、insert、delete 三种操作，也可以借用这种思想做一定程度的简化，因为篇幅关系我们不在这里赘述。如果大家还有其他想法，欢迎留言讨论！</p>
<p>参考文献<br><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a><br><a href="https://coolshell.cn/articles/21146.html">https://coolshell.cn/articles/21146.html</a></p>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/w1ebAgnzfDzoGG0sn6KGlQ">https://mp.weixin.qq.com/s/w1ebAgnzfDzoGG0sn6KGlQ</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
